# 实验四

## 实验目的

- 练习结构体的使用
- 练习字符串的基本操作
- 练习二维数组的使用
- 练习结构化程序设计

## 基础编程

### P4.1 实现gets

`gets(char str[])`是`stdio.h`中提供的读取字符串的函数，它从输入的字符序列中读取一个字符串，直到遇到换行符`\n`终止，读取的结果存放在`str`中，输入序列结尾的换行符将被抛弃。例如，运行下面的代码，输入字符串`Hello`并按回车，字符串`str`中的内容将是`{'H','e','l','l','o','\0'}`。

```c
#include <stdio.h>

int main() {
    char str[6];
    gets(str);
}
```

本题目要求你实现一个自己的`gets()`函数。它的作用是从输入序列中读取一个字符串，直到遇到换行符为止，将这个字符串存放在`str`中，并丢弃最后的换行符。请你使用下面的代码模板，仅修改`/* BEGIN YOUR CODES */`和`/* END YOUR CODES */`之间的内容。**仅允许使用getchar()来读取输入内容。**

```c
#include <stdio.h>
int main() {
    char str[60];
    /* BEGIN YOUR CODES */

    /* END YOUR CODES */
    puts(str);
    return 0;
}
```

提交OJ系统时，**仅提交`/* BEGIN YOUR CODES */`和`/* END YOUR CODES */`之间的内容**。

#### 输入

输入只有一行：

```
str
```

`str`是一个由ASCII字符构成的字符串，长度不超过60个字符，有且仅有一个换行符位于字符串最后。

#### 输出

输出只有一行：

```
str
```

这里的`str`与输入完全相同。（注：puts在输出的时候会自动添加换行符）

### P4.2 矩阵最值

给定一个矩阵，请你找出它每一行的最大值。

#### 输入

输入有$(N+1)$行。

```
N M
A11 A12 ... A1M
A21 A22 ... A2M
......
AN1 AN2 ... ANM
```

其中第一行有两个整数$N\;M$，中间以一个空格隔开，$N$为矩阵的行数，$M$为矩阵的列数。接下来N行，每行有M个整数，每两个整数之间以一个空格隔开，为矩阵的每个元素的值。

数据范围：$2\leq M,N\leq 10$，$-2147483647\leq A_{ij}\leq2147483647,\forall i\in[1,N],j\in[1,M]$

#### 输出

输出有$N+M$行：

```
max1
max2
...
maxN
```

其中`max1`\~`maxN`依次是第1~N行的最大值。

#### 示例

输入

```
2 3
1 2 3
2 5 -1
```

输出

```
3
5
```

## 进阶编程

### AP4.1 鞍点

鞍点是博弈论中的一个概念，如果矩阵中的一个值是它所在行的最大值，同时也是所在列的最小值，那么这个值就是鞍点。

*以下是废话可以不看*

鞍点代表着当博弈的一方(A)采取了对另一方(B)来说最差的行动时，B的最佳应对。例如，下面的矩阵（称为收益矩阵）不同的行代表A采取的不同策略，不同的列代表B采取的不同策略，中间的值代表A、B采取相应策略时，B所得到的收益。

|        | B采取策略甲 | B采取策略乙 | B采取策略丙 |
| ------ | ------ | ------ | ------ |
| A采取策略X | 3      | 5      | 1      |
| A采取策略Y | -3     | 7      | 9      |

可以看到，A如果要使B获得的收益最小，只能采取策略X，如果采取策略Y，则B采取策略丙时B将得到9的收益。而B也知道A一定会采取策略X，此时B的最佳应对就是策略乙。这里的A采取策略X、B采取策略乙就是这个问题的鞍点，同时也是纳什均衡点（任意一方改变策略，都不会得到比现在更好的收益）。

*废话结束*

输入一个矩阵，请你找出它的鞍点，并输出鞍点所在的行和列。如果鞍点不存在，输出`-1`。输入的数据保证每行只有一个最大值，每列只有一个最小值。

#### 输入

输入有$(N+1)$行。

```
N M
A11 A12 ... A1M
A21 A22 ... A2M
......
AN1 AN2 ... ANM
```

其中第一行有两个整数$N\;M$，中间以一个空格隔开，$N$为矩阵的行数，$M$为矩阵的列数。接下来N行，每行有M个整数，每两个整数之间以一个空格隔开，为矩阵的每个元素的值。

数据范围：$2\leq M,N\leq 10$，$-2147483647\leq A_{ij}\leq2147483647,\forall i\in[1,N],j\in[1,M]$

**输入的数据保证每行只有一个最大值，每列只有一个最小值。**

#### 输出

输出只有一行：

```
X Y
```

其中X是鞍点所在的行（**从1开始计数**），Y是鞍点所在的列（**从1开始计数**），中间以一个空格隔开。特别的，如果鞍点不存在，输出

```
-1
```

#### 示例

- 示例1
  
  - 输入
    
    ```
    2 3
    3 5 1
    -3 7 9
    ```
  
  - 输出
    
    ```
    1 2
    ```

- 示例2
  
  - 输入（这个其实就是石头剪刀布的收益矩阵）
    
    ```
    3 3
    0 -1 1
    1 0 -1
    -1 1 0
    ```
  
  - 输出（鞍点不存在所以别以为学了博弈论就能赢石头剪刀布）
    
    ```
    -1
    ```

## 持续设计

### CDP4.1 贪吃蛇

本次持续设计题目，我们将利用`windows.h`头文件提供的延时函数和获取键盘事件的函数，来实现一个可以用键盘上的方向键控制移动方向的贪吃蛇——的头。

#### 延时

实现延时使用的是`windows.h`中提供的`Sleep()`函数（注意S是大写）。请尝试下面的代码：

```c
#include <stdio.h
#include <windows.h>

int main() {
    while(1) {
        putchar('o');
        Sleep(500); // 延时500毫秒
    }
}
```

#### 获取键盘事件

获取键盘事件使用的是`windows.h`提供的`GetAsyncKeyState()`函数。它接受一个代表键盘上某个按键的参数，然后返回一个16位的整数，返回值**最低位为1**则表示在**上次调用**该函数获取**该按键**状态，到本次调用期间，该按键被按下过。我们需要读取的是四个方向键，代表它们的参数分别是`VK_UP`, `VK_DOWN`, `VK_LEFT`, `VK_RIGHT`。例如，下面代码：

```c
if( (GetAsyncKeyState(VK_UP) & 1) == 1 ) {
    // 向上键被按下过
}
```

用于判断自从上次调用`GetAsyncKeyState(VK_UP)`以来，键盘上的**向上键**是否被按下过。`& 1`的作用是取一个整数的最低位，可以不用关心具体原理，当作一个固定写法即可。如果向上键被按下过，表达式`(GetAsyncKeyState(VK_UP) & 1)`值为1，否则为0。

#### 使用枚举类型表示方向

为了表示贪吃蛇当前移动的方向，我们需要约定一种表示方式。例如，你可以用1代表向上、2代表向下，或者用字符型变量，u表示向上，d表示向下，等等。但是，我们有一种更好的表示方式，这就是枚举类型(enum)。

枚举类型可以为一些整数取一个特定的名字，从而用一个有具体含义的单词来代替它。例如，我们有上下左右四种方向，就可以声明一个名为`direction`的枚举类型：

```c
enum direction {
    up, down, left, right
}; // 注意这里的分号。这个类型声明放在main函数的上面
```

这里up\~right分别用来代表数字0\~3，不过我们并不需要知道它们代表的具体数字。定义了这个枚举类型后，我们就可以将up down left right当作像1 2 3一样的常数来使用了。

首先来声明一个用来存储方向的变量`dir`：

```c
enum direction dir; // 这里enum direction作为一个类型说明符是一个整体，就像int一样
```

接下来就可以为其赋值：

```c
dir = up;
```

甚至也可以用在`switch`语句中：

```c
switch(dir) {
    case up:
        //...
        break;
    case down:
        //......
}
```

#### 定位光标

在上一次实验中，我们已经了解了怎样定位光标，不过步骤略显繁琐，因此在今后的实验中，可以使用下面的函数来定位光标：

```c
void setPos(int x, int y) {
    if(x<0) x=0;
    if(y<0) y=0;
    HANDLE output=GetStdHandle(STD_OUTPUT_HANDLE);
    COORD pos;
    pos.X=(short)x;
    pos.Y=(short)y;
    SetConsoleCursorPosition(output,pos);
}
```

把上面的函数定义拷贝下来，放在main函数的上面，这样在main函数中就可以直接使用`setPos(x,y)`来定位光标了。

```c
setPos(2,5); // 将光标放置在第5行第2列（从0开始数）
```

#### 完善程序

下面给出程序的整体框架，大家只需要在这个框架下完成程序即可。

```c
#include <stdio.h>
#include <windows.h>

void setPos(int x, int y) {
    if(x<0) x=0;
    if(y<0) y=0;
    HANDLE output=GetStdHandle(STD_OUTPUT_HANDLE);
    COORD pos;
    pos.X=(short)x;
    pos.Y=(short)y;
    SetConsoleCursorPosition(output,pos);
}

enum direction {
    up,down,left,right
};

int main() {
    enum direction dir=up; // 声明dir变量存储贪吃蛇移动的方向，初始方向向上
    int x=20,y=20; // 蛇头一开始放置在(20,20)的位置

    while(1) {
        // 第一步：依次判断四个方向键有没有被按下过，根据方向键按下的情况给dir赋不同的值。
        //         请注意以下几点：
        //        1. 需要确保每次循环最多只改变一次dir的值，或者不改变
        //        2. 贪吃蛇不能后退

        // 第二步：在(x,y)处打印一个空格，擦除掉上次循环打印出的蛇头

        // 第三步：根据dir的值，改变x和y的值。如果x或y的值已经减为0了，就不要再减了。

        // 第四步：在新的(x,y)处打印一个字符o表示蛇头

        // 第五步：把光标移动到某个不碍事的地方（比如(0,0)），不然蛇头后面会跟着一个小尾巴

        // 第六步：延时500毫秒
    }

    return 0;
}
```

### CDP4.2 极简教务系统

本次实验请将CDP3.2所实现的系统修改为多用户系统。所有用户的信息请存放在一个结构体数组中，结构体的定义与CDP3.2相同。

```c
struct Info {
    int ID;
    char name[NSTRLEN];
    char pwd[PSTRLEN];
    char type;
};

struct Info AllUser[USRNUM]; // 所有用户的信息，USRNUM为系统用户数量上限，请用#define在程序开头定义
```

另外，由于用户数量一般是少于上限`USRNUM`的，因此还需要一个整型变量来存储`AllUser`数组中实际被使用的数量：

```c
int UsrNum;
```

用户登录时，需要依次匹配`USRNUM`中的ID信息，直到找到匹配的用户，然后再检查密码是否正确。需要注意的点有：

- 注意`AllUser`数组中实际被使用的数据有多少个，不要与未被使用的数据进行匹配
- 如果用户输入的ID在系统中不存在，也要让用户把密码输完，再告诉他“用户名或密码不正确”

`AllUser`中的用户数据可以在程序中直接初始化，注意同时要对`UsrNum`的值进行初始化。请在系统中至少设置一个教学秘书用户、一个教师用户和一个学生用户。同上次一样，除了登出功能以外，其他的功能都打印“当前功能未开放”后退回到菜单页面。

### CDP4.3 Alpha Tic-Tac-Toe

从本次实验开始，我们的实验正式从编写井字棋游戏转换为编写能够下井字棋的AI——Alpha Tic-Tac-Toe。

当然，鉴于我们目前还没有能力写出能够让AI获胜的程序（即使你有也先假设你没有吧），我们这次实验的目标就定低一点：编写一个随机落子的程序，让它能够和人对弈。

为了今后编写程序更加方便，也为了方便你理解以后强化学习的内容，我们以“动作”来表示某个落子选择。当然，最方便的做法是用一个结构体来表示它：

```c
struct Action {
    int rank; // 落子的行
    int col;  // 落子的列
};
```

为了产生随机的动作，我们需要一个产生随机数的方法。幸运的是，C语言已经提供了产生随机数的函数。

```c
#include <stdlib.h>
// 产生随机数的函数需要这个头文件，注意不是stdio


// 在需要随机数的地方
int randomNumber = rand();
```

但是，`rand()`函数产生的随机数范围是0~某个特别大的数，如何将范围限制在某个范围呢？其实用求余数的运算就可以解决：

```c
// 这行代码产生0~8之间的随机整数
int randomNumber = rand() % 9;
```

另外，你可能会发现你每次运行程序，得到的随机数都是一模一样的。这是因为C语言产生的是“伪随机数”，是通过一个“种子”数经过某些运算得到的，而每次运行程序的“种子”都是一样的。为了产生不同的随机数，你可以手动设置种子：

```c
srand(100); // 将随机数种子设置
```

还有一个方法是用当前的时间设置随机数种子，但是我们暂时还用不到——就先到此为止吧！

于是产生随机动作的代码如下：

```c
struct Action actions[9]; // 最多有9种可选的动作
int actionNum = 0; // 实际可选动作数量
for(int i = 0; i < 3; i++) {
    for(int j = 0; j < 3; j++) {
        // 如果格子是空的
            // actions[actionNum].rank = i;
            // actions[actionNum].col = j;
            // actionNum++;
    }
}
int actionIndex = rand() % actionNum;
// 执行动作actions[actionIndex]
```

好了，在实验三的基础上，实现人与随机落子AI的对弈吧！

> 补充内容：马尔可夫决策过程（一）（与本次实验内容无关，但与后面的有关）
> 
> 我们可以把某个序列决策的过程——例如下棋或者控制机器人移动到某个位置——抽象为下面的过程：
> 
> 初始状态$s_0 \to$ 选择动作$a_0 \to$ 进入状态$s_1 \to$ 选择动作$a_1 \to \cdots$ 
> 
> 在这个过程中，每一步如何选择动作$a$，被称为策略 (Policy) 。很显然，策略有很多种形式。例如，我们可以像本次实验那样，随机的选择一个动作，完全不关心状态是什么（实际上，由于我们排除了不合法的落子动作，所以我们编写的随机落子不完全和状态无关——不过先忽略这点）。在这种情况下，我们选择的动作其实服从一个概率分布$\pi(a)$，并且和状态毫无关系——即条件独立。
> 
> 当然，你也可以构造出一个策略，每一步选择的动作都考虑历史上所有的状态，你谨慎分析每一步的落子，最终下出了深思熟虑之后的一步，即：$a_t \sim \pi(a_t | s_t, s_{t-1},\dots,s_0)$。
> 
> 但是，介于这两种极端情况之间，还有一种情形，即每次选择的动作只取决于当前的状态，和历史状态毫无关系，即$a_t \sim \pi(a_t | s_t)$。当你的策略满足这一条件时，我们称它是“马尔可夫 (Markov)”的。这其实是对绝大部分序列决策问题的一个很好的近似：历史的影响都已经反映在当前状态下，即当前的状态已经包含了决策所需的全部信息。如果你的目光仅限于盘面，而不考虑棋手的心理等因素的话，井字棋无疑就是一个很好的例子。
> 
> 强化学习所研究的，就是马尔可夫决策过程中如何选择最优策略的问题。
